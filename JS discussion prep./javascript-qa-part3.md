# Core JavaScript Concepts - Technical Interview Defense (Part 3/10)

## Questions 41-60: Generators, Symbols, Proxies & Advanced Patterns

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 41 | What are generators? When would you use them? | Generators are functions that can pause and resume execution. Useful for iterators and async flow control. | `function* gen() { yield 1; yield 2; }` creates an iterator. Calling `gen().next()` returns `{value: 1, done: false}`. Each `yield` pauses execution. Use cases: (1) Custom iteration (tree traversal), (2) Infinite sequences (`function* fibonacci()`), (3) Async coordination (before async/await). Rarely needed in modern code—async/await replaced most use cases. | **Real-Life**: Generator is a video you can pause/resume. Regular function is a movie you watch straight through. **Code**: `function* count() { let i = 0; while(true) yield i++; } const c = count(); c.next().value; // 0, c.next().value; // 1`. Infinite counter without memory overflow (generates on-demand). |
| 42 | What's the `yield` keyword? How is it different from `return`? | `yield` pauses the generator and returns a value. `return` ends the generator. | `function* fn() { yield 1; yield 2; return 3; }` - first `.next()` returns 1, second returns 2, third returns `{value: 3, done: true}`. After `return`, subsequent `.next()` calls return `{value: undefined, done: true}`. Multiple `yield`s create a sequence; `return` finalizes it. | **Real-Life**: `yield` is a rest stop (pause, then continue). `return` is the destination (journey ends). **Code**: `function* gen() { yield 'a'; return 'b'; } const g = gen(); g.next(); // {value: 'a', done: false}, g.next(); // {value: 'b', done: true}, g.next(); // {value: undefined, done: true}`. |
| 43 | What are Symbols? Why would you use them over strings as object keys? | Symbols are unique, immutable primitives. They prevent key collisions in objects. | `const sym = Symbol('desc')` creates a unique value. `Symbol('x') !== Symbol('x')` (always unique). Use case: private-ish properties. `obj[sym] = 'secret'` - not enumerable in `Object.keys(obj)` or `for...in`. Strings risk collisions: `obj['id'] = 1` might overwrite library code adding `obj['id']`. Symbols guarantee uniqueness. | **Real-Life**: Symbols are fingerprints (globally unique). Strings are names (can collide—two "John Smith"s). **Code**: `const ID = Symbol('id'); obj[ID] = 123; Object.keys(obj); // [] (symbol keys hidden)`. `obj[ID]; // 123 (still accessible if you have the symbol)`. |
| 44 | What's the difference between `Symbol()` and `Symbol.for()`? | `Symbol()` creates a new unique symbol. `Symbol.for(key)` retrieves/creates a global shared symbol. | `Symbol('x') !== Symbol('x')` (new symbol each time). `Symbol.for('x') === Symbol.for('x')` (global registry). `Symbol.for` is for cross-realm communication (iframes, modules sharing symbols). Most code uses `Symbol()` (local uniqueness). `Symbol.keyFor(sym)` retrieves the registry key. | **Real-Life**: `Symbol()` is a custom password (unique to you). `Symbol.for()` is a shared password in a vault (anyone with the key accesses the same one). **Code**: `const s1 = Symbol('x'), s2 = Symbol('x'); s1 === s2; // false`. `const g1 = Symbol.for('x'), g2 = Symbol.for('x'); g1 === g2; // true`. |
| 45 | What are well-known Symbols (like `Symbol.iterator`)? | Well-known Symbols are built-in symbols that customize object behavior (iteration, type coercion, etc.). | `Symbol.iterator` makes objects iterable: `obj[Symbol.iterator] = function*() { yield 1; }` enables `for (let x of obj)`. Other: `Symbol.toStringTag` (customize `Object.prototype.toString`), `Symbol.toPrimitive` (control type coercion). These let you override language-level behavior. | **Real-Life**: Well-known Symbols are standardized knobs (volume, brightness) on a device. Custom symbols are DIY buttons. **Code**: `const obj = { *[Symbol.iterator]() { yield 1; yield 2; } }; [...obj]; // [1,2]`. Without iterator: `[...obj]` throws "obj is not iterable". |
| 46 | What's a Proxy? How does it differ from getters/setters? | Proxy intercepts operations on an object (get, set, delete, etc.). Getters/setters only handle property access. | `const p = new Proxy(obj, { get(target, prop) { return target[prop] * 2; } });` - reading `p.x` doubles the value. Proxy can intercept: 13 traps including `has` (in operator), `deleteProperty`, `apply` (function calls). Getters/setters are per-property: `obj = { get x() { return this._x * 2; } }`. Proxy is whole-object. | **Real-Life**: Getter/setter is a locked drawer (controls one item). Proxy is a security checkpoint (controls entire room access). **Code**: `const p = new Proxy({}, { get(t, k) { return k in t ? t[k] : 'default'; } }); p.missing; // 'default'`. Getter: `obj = { get x() { return 'x'; } }; obj.y; // undefined (no fallback for y)`. |
| 47 | What are the use cases for Proxy? | Validation, logging, default values, reactive frameworks (Vue 3 uses Proxy for reactivity). | Validation: `new Proxy(obj, { set(t, k, v) { if (typeof v !== 'number') throw Error; t[k] = v; } })` - type-check on assignment. Logging: intercept all property reads. Default values: return fallback for missing keys. Vue 3: `new Proxy(data, { set() { triggerRerender(); } })` - auto-updates UI on data change. | **Real-Life**: Proxy is a middleman (intercepts all transactions). Without it: direct dealings (no oversight). **Code**: `const validator = new Proxy({}, { set(t, k, v) { if (k === 'age' && v < 0) throw Error('Invalid age'); t[k] = v; } }); validator.age = -5; // Error thrown`. |
| 48 | What's the Reflect API? Why use it with Proxy? | Reflect is a set of methods mirroring Proxy traps. It provides default behavior for intercepted operations. | `Reflect.get(obj, key)` is like `obj[key]` but standardized. In Proxy traps, use Reflect to forward operations: `get(target, prop) { log(prop); return Reflect.get(target, prop); }` (log then execute default behavior). Without Reflect: manual `target[prop]` (error-prone for edge cases). | **Real-Life**: Reflect is a reference manual (shows how operations normally work). Without it: you reinvent the wheel. **Code**: `const p = new Proxy({x:1}, { get(t, k) { console.log(k); return Reflect.get(t, k); } }); p.x; // logs 'x', returns 1`. Manual: `return t[k]` (works here, but breaks for getters/prototypes—Reflect handles them). |
| 49 | What's a WeakMap? How is it different from Map? | WeakMap keys must be objects and are garbage-collected when no other references exist. | `const wm = new WeakMap(); wm.set(obj, 'data');` - if `obj` is deleted, the entry auto-removes (prevents memory leaks). Regular `Map` keeps keys alive (even if `obj = null`, Map's reference prevents GC). Limitations: WeakMap keys must be objects, no iteration (can't list keys). Use case: private data storage (DOM nodes as keys). | **Real-Life**: WeakMap is Post-it notes (fall off when object is removed). Map is glue (holds object forever). **Code**: `let obj = {}; const wm = new WeakMap(); wm.set(obj, 'data'); obj = null; // wm entry is GC'd`. Map: `const m = new Map(); m.set(obj, 'data'); obj = null; // m still holds the object (memory leak)`. |
| 50 | What's a WeakSet? When would you use it? | WeakSet stores objects without preventing garbage collection. Useful for tracking "has been seen" without leaking memory. | `const ws = new WeakSet(); ws.add(obj);` - if `obj` is deleted, it auto-removes from set. Use case: marking DOM nodes as "processed" without preventing their removal. Regular `Set` would keep nodes alive even after removal from DOM (memory leak). | **Real-Life**: WeakSet is a guest list (names disappear when guests leave). Set is a permanent roster (names stay forever). **Code**: `const ws = new WeakSet(); let div = document.createElement('div'); ws.add(div); ws.has(div); // true. div = null; // div is GC'd, ws entry removed`. |
| 51 | What's the difference between shallow equality and deep equality? | Shallow checks references (===). Deep recursively compares nested values. | `{a:1} === {a:1}` is `false` (different references). Deep equality: `JSON.stringify(obj1) === JSON.stringify(obj2)` (naive, fails for functions/order). Libraries (Lodash `_.isEqual`) handle edge cases (circular refs, Dates, RegExp). For primitives, `===` is deep equality. For objects, need custom comparison. | **Real-Life**: Shallow is comparing book covers (same title?). Deep is comparing page-by-page content. **Code**: `const a = {x:1}, b = {x:1}; a === b; // false (shallow)`. Deep: `JSON.stringify(a) === JSON.stringify(b); // true`. But: `{x:1, y:2} vs {y:2, x:1}` (different order, stringify fails). Use library: `_.isEqual(a, b)`. |
| 52 | What's memoization? How would you implement it? | Memoization caches function results to avoid redundant computation. | `const memo = {}; function fib(n) { if (n in memo) return memo[n]; const result = fib(n-1) + fib(n-2); memo[n] = result; return result; }` - caches previous results. Without memoization, `fib(40)` takes seconds (recomputes same values). With: instant (looks up cache). Lodash `_.memoize` generalizes this. | **Real-Life**: Memoization is a cheat sheet (look up answers instead of recalculating). Without it: redo math every time. **Code**: `function expensiveCalc(x) { return x * x; } const memoized = _.memoize(expensiveCalc); memoized(5); // calculates, memoized(5); // returns cached 25`. |
| 53 | What's currying? Give an example. | Currying transforms `f(a, b)` into `f(a)(b)`. Useful for partial application and function composition. | `const add = (a) => (b) => a + b;` - `add(2)` returns a function that adds 2 to its input. `const add2 = add(2); add2(3); // 5`. Use case: reusable configs. `const fetchJSON = (url) => (options) => fetch(url, options).then(r => r.json());` - `const getUser = fetchJSON('/user'); getUser({method:'GET'});`. | **Real-Life**: Currying is a multi-step form (fill name, then address). Regular function is a single-page form (all at once). **Code**: `const multiply = (a) => (b) => a * b; const double = multiply(2); double(5); // 10`. Without currying: `function multiply(a, b) { return a * b; }` - can't easily create `double`. |
| 54 | What's a closure "gotcha" with loops and `var`? | `var` is function-scoped. Closures in loops capture the same `i`, not each iteration's value. | `for (var i = 0; i < 3; i++) { setTimeout(() => console.log(i), 100); }` logs `3, 3, 3` (all closures share the same `i`, which ends at 3). Fix: use `let` (block-scoped, creates new `i` per iteration) or IIFE: `(function(i) { setTimeout(() => console.log(i), 100); })(i);`. | **Real-Life**: `var` is one shared whiteboard (everyone sees final value). `let` is individual notepads (each person keeps their own). **Code**: `for (var i = 0; i < 3; i++) { setTimeout(() => console.log(i), 0); }` logs `3,3,3`. `for (let i = 0; i < 3; i++)` logs `0,1,2` (each timeout captures unique `i`). |
| 55 | What's an Immediately Invoked Function Expression (IIFE)? | IIFE is a function that runs immediately: `(function() { ... })()`. Creates private scope. | `(function() { const secret = 'hidden'; })();` - `secret` isn't accessible outside (function scope). Pre-ES6, used to avoid global pollution (modules now handle this). Still useful for one-off initialization: `const result = (function() { /* complex setup */ return value; })();`. | **Real-Life**: IIFE is a pop-up tent (set up, use, disappear). Regular function is a permanent building. **Code**: `(function() { const x = 5; })(); console.log(x); // ReferenceError (x is private)`. Without IIFE: `const x = 5; console.log(x); // 5 (global pollution)`. |
| 56 | What's the difference between `Function.prototype.call/apply/bind`? | All change `this`. `call` takes args individually, `apply` takes array, `bind` returns new function (doesn't invoke). | `fn.call(obj, a, b)` - invokes immediately. `fn.apply(obj, [a, b])` - same but array args. `fn.bind(obj)` - returns new function with `this` locked to `obj`. Use `call/apply` for immediate invocation, `bind` for later (event handlers). | **Real-Life**: `call/apply` are making a phone call now. `bind` is scheduling a call for later. **Code**: `function greet(greeting) { return `${greeting}, ${this.name}`; } const user = {name: 'Alice'}; greet.call(user, 'Hi'); // 'Hi, Alice'`. `greet.apply(user, ['Hi']);` - same. `const bound = greet.bind(user); bound('Hi');` - later invocation. |
| 57 | What's function composition? How does it differ from chaining? | Composition combines functions: `f(g(x))`. Chaining calls methods on the same object: `obj.a().b()`. | `const compose = (f, g) => (x) => f(g(x));` - applies `g` then `f`. `const add1 = x => x+1; const double = x => x*2; const add1ThenDouble = compose(double, add1); add1ThenDouble(3); // 8 (3+1=4, 4*2=8)`. Chaining: `str.trim().toUpperCase().split(' ')` - each method returns a string. | **Real-Life**: Composition is an assembly line (output of one feeds next). Chaining is a to-do list (check off tasks in order). **Code**: `const f = x => x + 1; const g = x => x * 2; compose(g, f)(3); // 8`. Chaining: `'hello'.toUpperCase().split(''); // ['H','E','L','L','O']`. |
| 58 | What's the difference between `Object.freeze()` and `Object.seal()`? | `freeze` makes object immutable (no add/edit/delete). `seal` prevents add/delete but allows editing existing props. | `Object.freeze(obj); obj.x = 5; // fails (strict mode: error, non-strict: silent)`. `Object.seal(obj); obj.x = 5; // works (edit allowed), obj.y = 2; // fails (add blocked)`. Shallow: nested objects aren't frozen. Deep freeze requires recursion. | **Real-Life**: `freeze` is encasing in ice (completely unchangeable). `seal` is a locked box (contents can shift, but can't add/remove items). **Code**: `const obj = {x:1}; Object.freeze(obj); obj.x = 2; obj.x; // still 1 (edit blocked)`. `Object.seal(obj); obj.x = 2; obj.x; // 2 (edit allowed), obj.y = 3; // fails silently`. |
| 59 | What's the difference between `Object.create(proto)` and `new Constructor()`? | `Object.create(proto)` sets `proto` as `__proto__`. `new` calls constructor function and sets `Constructor.prototype` as `__proto__`. | `const obj = Object.create(parentObj);` - `obj.__proto__ === parentObj`. `new Func()` does: (1) create empty object, (2) set `obj.__proto__ = Func.prototype`, (3) call `Func.call(obj)`, (4) return `obj`. `Object.create` is lower-level (no constructor call). | **Real-Life**: `Object.create` is adopting traits (skip the birth process). `new` is natural birth (inheritance + initialization). **Code**: `const parent = {x:1}; const child = Object.create(parent); child.x; // 1 (inherited)`. `function Func() { this.x = 1; } const obj = new Func(); obj.x; // 1 (from constructor)`. |
| 60 | What's the difference between `throw new Error()` and `throw 'error'`? | `throw new Error()` creates an Error object with stack trace. `throw 'string'` throws anything but loses debugging info. | `throw new Error('Oops')` includes: (1) message, (2) stack trace (call history), (3) works with `catch (e) { console.log(e.stack); }`. `throw 'Oops'` just throws a string (no stack). Always throw Error objects for debugging. Custom errors: `class ValidationError extends Error {}`. | **Real-Life**: `Error` object is a detailed police report (who, what, where). String is a vague note ("something happened"). **Code**: `try { throw new Error('Failed'); } catch (e) { console.log(e.stack); }` - logs full trace. `try { throw 'Failed'; } catch (e) { console.log(e.stack); }` - undefined (no stack on strings). |

---

**Progress: 60/200 questions complete for JavaScript track.**

Ready for the next batch? (Questions 61-80 will cover: Event propagation (bubbling/capturing), Custom events, Mutation Observer, Intersection Observer, Performance APIs (PerformanceObserver), Module patterns, and Memory profiling techniques)
