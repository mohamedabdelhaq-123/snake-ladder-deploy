# Core JavaScript Concepts - Technical Interview Defense (Part 2/10)

## Questions 21-40: Prototypes, Operators & ES6+ Features

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 21 | Explain prototypal inheritance. How is it different from class-based? | Every object has a prototype (parent). Objects inherit properties by walking the prototype chain. | In JS, `const obj = {}` secretly has `obj.__proto__ = Object.prototype`. When you access `obj.toString()`, JS checks: (1) Does `obj` have `toString`? No. (2) Does `obj.__proto__` have it? Yes! Found. This chain continues until `null`. Classes (`class Player extends Entity`) are syntactic sugar—they still use prototypes under the hood. | **Real-Life**: You inherit DNA from parents (prototype chain). You look for traits (methods) in yourself first, then parents, then grandparents. **Code**: `const obj = {}; obj.hasOwnProperty('x'); // false, but works because Object.prototype has hasOwnProperty`. `obj.__proto__ === Object.prototype; // true`. |
| 22 | What's the difference between `__proto__` and `prototype`? | `__proto__` is the actual link to the parent. `prototype` is a template for creating children. | `obj.__proto__` points to the parent object. `Func.prototype` is what new instances will inherit: `const x = new Func(); x.__proto__ === Func.prototype`. Think: `prototype` is a blueprint, `__proto__` is the built house's foundation. Only functions have `prototype`. All objects have `__proto__`. | **Real-Life**: `prototype` is a cookie cutter (makes copies). `__proto__` is the actual lineage (your family tree). **Code**: `function Player() {} Player.prototype.move = () => {}; const p = new Player(); p.__proto__ === Player.prototype; // true`. `p.move()` works because of `__proto__` chain. |
| 23 | Explain the spread operator `...`. Why is it useful? | Spread expands iterables (arrays, objects) into individual elements. | `[...arr]` creates a shallow copy of an array. `[...arr1, ...arr2]` concatenates without mutating originals. `{...obj}` copies object properties. Spread is non-destructive—originals remain unchanged. I use it for immutable updates: `const newArr = [...oldArr, newItem]` instead of `oldArr.push(newItem)`. | **Real-Life**: Spread is unpacking a suitcase (each item laid out). Without it, you carry the whole suitcase. **Code**: `const a = [1,2]; const b = [...a, 3]; // [1,2,3], a unchanged`. Object: `const obj2 = {...obj1, x: 2}; // copies obj1, overrides x`. |
| 24 | What's the rest parameter `...args`? How is it different from `arguments`? | Rest collects multiple arguments into an array. `arguments` is an array-like object (missing array methods). | `function sum(...nums) { return nums.reduce((a,b) => a+b, 0); }` - `nums` is a real array. `arguments` is array-like: `function old() { console.log(arguments[0]); arguments.map(x => x); // ERROR, no .map }`. Rest is modern, works with arrow functions. `arguments` is legacy. | **Real-Life**: Rest parameter is a net (catches everything). `arguments` is a box (holds items, but you can't directly sort them). **Code**: `function fn(...args) { args.map(x => x*2); }` - works. `function fn() { arguments.map(x => x*2); }` - fails. Must convert: `Array.from(arguments).map(...)`. |
| 25 | Explain destructuring. When do you use it? | Destructuring extracts values from arrays/objects into variables in one line. | `const {name, age} = player` instead of `const name = player.name; const age = player.age;`. Array: `const [first, second] = arr`. I use it for: (1) function parameters: `function move({x, y})` (no need to pass entire point), (2) multiple returns: `return {winner, score}; const {winner} = game();`, (3) swapping: `[a, b] = [b, a]`. | **Real-Life**: Destructuring is unpacking a care package (take only what you need). Without it: unpack everything, then pick items. **Code**: `const {x, y} = point; move(x, y);` vs `const x = point.x; const y = point.y; move(x, y);` - same result, less typing. Swap: `[a, b] = [b, a]; // no temp variable needed`. |
| 26 | What are template literals? Why use them over string concatenation? | Template literals use backticks and `${}` for embedded expressions. Cleaner than `+` concatenation. | `` `Hello ${name}` `` vs `'Hello ' + name`. Benefits: (1) multi-line strings (`` `Line1\nLine2` ``), (2) expression evaluation (`` `Sum: ${a+b}` ``), (3) readability (no quote juggling). I use them for HTML generation: `` `<div class="${cls}">${text}</div>` ``. | **Real-Life**: Template literals are Mad Libs (fill in blanks). Concatenation is taping pieces of paper together. **Code**: `` `Player ${id} rolled ${dice}` `` vs `'Player ' + id + ' rolled ' + dice` - easier to read. Multi-line: `` `<div>\n  ${content}\n</div>` `` (natural indentation). |
| 27 | What's the difference between `function() {}` and `() => {}`? | Arrow functions don't have their own `this`, `arguments`, or `super`. They inherit from the parent scope. | Regular functions get a new `this` based on how they're called. Arrow functions "freeze" `this` to where they're defined. `setTimeout(function() { console.log(this); }, 100);` - `this` is `window`. `setTimeout(() => { console.log(this); }, 100);` - `this` is the surrounding object. No `arguments` object in arrows. | **Real-Life**: Regular function is a chameleon (changes `this` based on environment). Arrow function is a photo (captures `this` at definition time). **Code**: `const obj = { x: 1, fn() { setTimeout(() => console.log(this.x), 100); } }; obj.fn(); // logs 1 (arrow inherits obj)`. Regular function: logs `undefined` (`this` is window). |
| 28 | Explain `call`, `apply`, and `bind`. When do you use each? | All three change `this`. `call` invokes immediately with args. `apply` uses array. `bind` returns a new function. | `fn.call(thisArg, arg1, arg2)` - runs `fn` with `this = thisArg`. `fn.apply(thisArg, [arg1, arg2])` - same, but args as array. `fn.bind(thisArg)` - returns new function with locked `this` (doesn't execute). I use `bind` for event listeners: `button.onclick = this.handleClick.bind(this)` (preserve class instance as `this`). | **Real-Life**: `call/apply` are phone calls (immediate). `bind` is scheduling a call (later execution). **Code**: `function greet(msg) { console.log(msg, this.name); } const user = {name: 'Alice'}; greet.call(user, 'Hi'); // 'Hi Alice'`. `greet.apply(user, ['Hi']);` - same. `const bound = greet.bind(user); bound('Hi');` - delayed. |
| 29 | What's the difference between `Object.assign()` and spread `{...obj}`? | Both shallow copy. `Object.assign` mutates the first argument. Spread creates a new object. | `Object.assign(target, source)` copies `source` into `target` and returns `target` (mutated). `{...obj}` always creates a new object. For merging: `Object.assign({}, obj1, obj2)` vs `{...obj1, ...obj2}` (same result). Spread is more readable. | **Real-Life**: `Object.assign` is pouring water into an existing cup (cup changes). Spread is pouring into a new cup (original safe). **Code**: `const a = {x:1}; Object.assign(a, {y:2}); a; // {x:1, y:2} (mutated)`. `const b = {...a, y:2}; a; // {x:1} (unchanged), b; // {x:1, y:2}`. |
| 30 | Explain `async/await`. How does it differ from Promises? | `async/await` is syntactic sugar over Promises. Makes async code look synchronous. | `async function fn() { const data = await fetch(url); }` pauses execution until `fetch` resolves. Equivalent: `fetch(url).then(data => ...)`. Benefits: (1) easier error handling with `try/catch`, (2) avoids "callback hell" (nested `.then()`), (3) reads top-to-bottom. Under the hood, `await` yields to the event loop and resumes on resolution. | **Real-Life**: Promises are IOU notes (I owe you data). `async/await` is waiting at a counter until the cashier hands you change. **Code**: Promise: `fetch(url).then(r => r.json()).then(data => use(data));`. Async/await: `const r = await fetch(url); const data = await r.json(); use(data);` - linear, clearer. |
| 31 | What's the difference between `Array.filter()` and `Array.find()`? | `filter` returns all matches (array). `find` returns the first match (single element). | `[1,2,3,4].filter(x => x > 2)` → `[3,4]`. `[1,2,3,4].find(x => x > 2)` → `3` (stops after first). `find` is more efficient when you only need one result (doesn't iterate the rest). `filter` collects all. I use `find` for "get player by ID", `filter` for "get all winning players". | **Real-Life**: `find` is "show me the first red apple". `filter` is "show me all red apples". **Code**: `players.find(p => p.id === 1); // returns Player object or undefined`. `players.filter(p => p.score > 50); // returns array of high scorers`. |
| 32 | Explain `Array.some()` and `Array.every()`. | `some` returns true if any element passes the test. `every` returns true only if all pass. | `[1,2,3].some(x => x > 2)` → `true` (3 passes). `[1,2,3].every(x => x > 2)` → `false` (1 and 2 fail). Both short-circuit (stop on first definitive result). I use `some` for "is there a winner?", `every` for "are all players ready?". | **Real-Life**: `some` is "does anyone have a key?" `every` is "does everyone have a key?" **Code**: `players.some(p => p.position.key() === goal); // true if any player won`. `players.every(p => p.ready); // true only if all players marked ready`. |
| 33 | What's the difference between `parseInt()` and `Number()`? | `parseInt` parses until it hits a non-digit. `Number()` requires the entire string to be numeric. | `parseInt('123abc')` → `123`. `Number('123abc')` → `NaN`. `parseInt('10', 10)` uses base-10 (important: always pass radix to avoid octal bugs). `Number('10')` is stricter but cleaner for validated input. I use `Number()` for user input (fail fast on invalid) and `parseInt` for parsing mixed strings. | **Real-Life**: `parseInt` is "read until you hit gibberish". `Number()` is "this must be a pure number or I reject it". **Code**: `parseInt('50px')` → `50` (useful for CSS). `Number('50px')` → `NaN` (strict). `parseInt('08')` → `8` (base-10 with radix). Without radix: `parseInt('08')` → `0` in old browsers (treated as octal). |
| 34 | What's the difference between `!!value` and `Boolean(value)`? | Both convert to boolean. `!!` is a double NOT operator. `Boolean()` is explicit coercion. | `!!value` is shorthand: first `!` inverts to boolean (truthy → false), second `!` inverts back (false → true). `Boolean(value)` calls the Boolean constructor. Same result: `!!0` → `false`, `Boolean(0)` → `false`. `!!` is common in code but less readable. | **Real-Life**: `!!` is a double negative ("not not hungry" = hungry). `Boolean()` is stating it directly ("I am hungry"). **Code**: `!!'hello'` → `true`, `!!''` → `false`. `Boolean('hello')` → `true`, `Boolean('')` → `false`. Both convert, `Boolean()` is clearer for beginners. |
| 35 | Explain the ternary operator. When do you avoid it? | Ternary is `condition ? trueValue : falseValue`. Avoid nesting it—use `if/else` for clarity. | `const msg = isWinner ? 'Won' : 'Lost'` is clean. Nested: `const msg = isWinner ? 'Won' : isDraw ? 'Draw' : 'Lost'` is hard to read (use `if/else` instead). Ternary is for simple A-or-B choices, not complex logic. | **Real-Life**: Ternary is a fork in the road (left or right). Nested ternary is a maze (confusing turns). **Code**: Good: `return x > 0 ? 'positive' : 'negative'`. Bad: `return x > 0 ? y > 0 ? 'A' : 'B' : z > 0 ? 'C' : 'D'` - unreadable. Refactor to `if/else`. |
| 36 | What's the nullish coalescing operator `??`? How is it different from `||`? | `??` checks for `null/undefined`. `||` checks for falsy values (0, '', false). | `const x = value ?? 'default'` - only uses default if `value` is `null` or `undefined`. `const x = value || 'default'` - uses default if `value` is 0, false, '', etc. Useful when 0 is valid: `const count = userInput ?? 10` (if userInput is 0, keeps 0; if undefined, uses 10). | **Real-Life**: `??` is "is this box completely empty?" (null/undefined). `||` is "is this box lacking substance?" (includes 0, false). **Code**: `const x = 0 ?? 5; // 0 (0 is not null)`. `const x = 0 || 5; // 5 (0 is falsy)`. `const x = null ?? 5; // 5 (null triggers default)`. |
| 37 | What's optional chaining `?.`? When do you use it? | `?.` safely accesses nested properties. Returns `undefined` if any part is null/undefined. | `const name = user?.profile?.name` - if `user` or `profile` is null, returns `undefined` instead of throwing TypeError. Prevents: `if (user && user.profile) { name = user.profile.name; }` boilerplate. I use it for optional data (API responses with missing fields). | **Real-Life**: Optional chaining is "knock before entering each room". Without it: "barge in and crash if room is locked". **Code**: `const zip = address?.location?.zip; // undefined if address or location is null`. Old way: `const zip = address && address.location && address.location.zip;` - verbose. |
| 38 | What's the difference between `in` operator and `hasOwnProperty()`? | `in` checks the entire prototype chain. `hasOwnProperty` checks only the object itself. | `'toString' in obj` → `true` (inherited from Object.prototype). `obj.hasOwnProperty('toString')` → `false` (not directly on obj). I use `hasOwnProperty` to avoid prototype pollution (malicious code adding properties to Object.prototype). | **Real-Life**: `in` is "do you or your ancestors have this?" `hasOwnProperty` is "do you personally have this?" **Code**: `const obj = {x: 1}; 'x' in obj; // true`. `'toString' in obj; // true (inherited)`. `obj.hasOwnProperty('toString'); // false (not own property)`. |
| 39 | Explain `typeof` and `instanceof`. When do you use each? | `typeof` checks primitive types. `instanceof` checks if an object is an instance of a class/constructor. | `typeof 5` → `'number'`. `typeof {}` → `'object'` (not specific). `typeof null` → `'object'` (JS bug). `instanceof`: `[] instanceof Array` → `true`. `{} instanceof Array` → `false`. I use `typeof` for primitives (string, number, boolean) and `instanceof` for objects (checking class hierarchy). | **Real-Life**: `typeof` is "what general category?" (fruit). `instanceof` is "is this a specific fruit?" (apple). **Code**: `typeof 'hi'` → `'string'`. `'hi' instanceof String` → `false` (primitive, not object). `new String('hi') instanceof String` → `true` (object wrapper). |
| 40 | What's the difference between `for...in` and `for...of`? | `for...in` iterates over object keys. `for...of` iterates over iterable values (arrays, strings). | `for (let key in obj)` - loops over property names. `for (let val of arr)` - loops over array elements. `for...in` is for objects (key-value pairs). `for...of` is for arrays/strings (ordered collections). Don't use `for...in` on arrays (iterates indices as strings, includes prototype properties). | **Real-Life**: `for...in` is reading a dictionary (looking at words). `for...of` is reading a list (reading entries in order). **Code**: `const obj = {a:1, b:2}; for (let k in obj) console.log(k); // 'a', 'b'`. `const arr = [1,2]; for (let v of arr) console.log(v); // 1, 2`. Arrays: `for (let i in [10,20]) console.log(i); // '0', '1' (strings!)` - wrong. Use `for...of`. |

---

**Progress: 40/200 questions complete for JavaScript track.**

Ready for the next batch? (Questions 41-60 will cover: Generators, Symbols, WeakMap/WeakSet, Proxies, Error handling patterns, Memory management, and Performance optimization techniques)
