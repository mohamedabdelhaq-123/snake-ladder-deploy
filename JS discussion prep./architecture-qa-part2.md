# Architecture & Design Decisions - Interview Defense Bank (Part 2/10)

## Questions 21-40: Mobile, Performance & Advanced Patterns

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 21 | How do you handle mobile responsiveness without media queries everywhere? | I use Flexbox with percentage-based layouts and a single mobile breakpoint at 768px. | Flexbox automatically reflows content (`flex-wrap: wrap`) when containers shrink. I set widths as percentages (`width: 48%`) rather than pixels, so they scale naturally. Media queries only override specific pain points (font sizes, grid columns). This "mobile-first responsive" approach means 80% of the layout works on all screens without device-specific code. | **Real-Life**: Water fills any container (Flexbox). You don't need instructions for each glass size. **Code**: `.player-info { display: flex; flex-wrap: wrap; gap: 2%; } .card { flex: 1 1 30%; }` - automatically stacks on narrow screens. One `@media (max-width: 768px)` adjusts font sizes. |
| 22 | Your event listeners are inline in HTML sometimes (`onclick="..."`). Isn't that bad practice? | I avoid inline handlers—all my listeners are in JS files using `addEventListener` for separation of concerns. | Inline handlers (`<button onclick="doThing()">`) mix structure (HTML) and behavior (JS), making debugging hard (errors don't show line numbers). They also pollute the global scope (function must be `window.doThing`). I use `addEventListener` exclusively, which allows multiple handlers, easy removal (`removeEventListener`), and keeps JS in `.js` files. | **Real-Life**: Inline handlers are writing instructions directly on a tool (hard to change). `addEventListener` is a separate instruction manual (easy to update). **Code**: Bad: `<button onclick="roll()">`. Good: `button.addEventListener('click', () => roll());` - testable, modular, no global pollution. |
| 23 | How do you prevent memory leaks from event listeners? | I remove listeners when components are destroyed and avoid creating new closures in loops. | Memory leaks happen when listeners reference DOM elements that should be garbage collected. If I do `element.addEventListener('click', handler)` but never `removeEventListener`, the element stays in memory even after removal from DOM. For dynamic elements (player markers), I use event delegation (one listener on parent) instead of per-element listeners. | **Real-Life**: Event listeners are strings attached to balloons. If you don't cut the string (remove listener), the balloon never floats away (garbage collection blocked). **Code**: `const handler = () => {...}; btn.addEventListener('click', handler); btn.removeEventListener('click', handler);` - reuses same function reference for removal. Arrow functions in loops create new closures each iteration (leak risk). |
| 24 | Your animations use CSS transitions. Why not JavaScript animations (requestAnimationFrame)? | CSS transitions are GPU-accelerated and declarative. JavaScript animations require manual frame management. | CSS transitions (`transform: translate(x, y); transition: 0.3s`) run on the compositor thread (GPU), separate from JavaScript's main thread. This means animations never block game logic. `requestAnimationFrame` would require: (1) calculate position each frame, (2) update styles 60 times/second, (3) handle timing manually. For simple A→B movement, CSS is 10x simpler and smoother. | **Real-Life**: CSS is an automatic car (shift gears for you). `requestAnimationFrame` is manual (you control every gear change). **Code**: CSS: `el.style.transform = 'translate(100px, 0)'; el.style.transition = 'transform 0.3s';` - browser handles frames. JS: `function animate() { el.style.left = x + 'px'; x += 2; if (x < 100) requestAnimationFrame(animate); }` - 20+ lines for same effect. |
| 25 | How do you decide which data to store in LocalStorage vs in-memory? | Persistent data (names, leaderboard) → LocalStorage. Session data (current turn, animations) → memory. | LocalStorage survives page refresh but has 5-10MB limit and synchronous I/O (blocks main thread). I store: (1) Player accounts (names, avatars), (2) Game state (positions, cards) for resume, (3) Leaderboard history. Transient state (hovered card, dice animation frame) stays in memory—no reason to persist. | **Real-Life**: LocalStorage is your hard drive (survives reboot). Memory is RAM (fast, but cleared on restart). **Code**: Persistent: `localStorage.setItem('leaderboard', JSON.stringify(scores));`. Transient: `let hoveredCard = null;` - no storage needed. |
| 26 | Your file structure has separate folders for `game-logic`, `pages`, `utils`. Why this organization? | Folders separate concerns by layer: logic (business rules), pages (UI), utils (reusable tools). | `game-logic/` contains pure logic (Game, Player, Grid classes) with zero DOM references—testable in isolation. `pages/` contains UI controllers (DOM manipulation, event handlers). `utils/` has helpers (Point class, diceRoll function). This layered architecture means I can swap the UI (React instead of Vanilla JS) without touching game logic. | **Real-Life**: A restaurant: kitchen (game-logic), waiters (pages), utensils (utils). Kitchen doesn't know about tables, waiters don't cook. **Code**: `game-logic/game.js` exports `class Game { playTurn() }`. `pages/game-board.js` imports: `import Game from '../game-logic/game.js'; game.playTurn(); updateDOM();` - logic and UI separated. |
| 27 | You use ES6 classes. Why not factory functions or prototypes? | Classes provide clear inheritance syntax and are familiar to developers from OOP backgrounds. | Factory functions (`function makePlayer() { return { ... } }`) work but lack native inheritance (must manually copy methods). Prototypes (`Player.prototype.move = ...`) are verbose. Classes are syntactic sugar over prototypes but read cleaner: `class Player extends Entity` vs manual prototype chaining. For a game with clear hierarchies (PortalTile extends Tile), classes are intuitive. | **Real-Life**: Classes are IKEA instructions (standardized, everyone understands). Factory functions are custom blueprints (work, but harder to share). **Code**: Class: `class Tile { effect() {} }; class PortalTile extends Tile { effect() { super.effect(); ... } }`. Factory: `function makeTile() { return { effect: () => {} } }` - no native `super`, must manually delegate. |
| 28 | How do you handle errors in your game? Are there try-catch blocks? | I throw errors during development for fast failure. In production, I'd wrap the game loop in try-catch and show a modal. | Internal errors (invalid position, null reference) should crash during dev—they indicate bugs, not user errors. Catching them hides issues. In production, I'd wrap public entry points: `try { game.playTurn() } catch(e) { showErrorDialog('Game error. Restart?'); logError(e); }`. User errors (duplicate names) are handled with validation, not exceptions. | **Real-Life**: Dev errors are fire alarms (stop everything). Production errors are sprinklers (contain damage, alert user). **Code**: Dev: `if (!valid) throw new Error('Bug!');`. Prod: `try { game.playTurn(); } catch(e) { alert('Oops!'); reportToServer(e); }` - graceful degradation. |
| 29 | Your Grid class has both `advance()` and `distToPoint()`. Why separate them? | `advance()` is high-level (game logic). `distToPoint()` is low-level (coordinate math). Separation enables testing. | `advance(player, 5)` handles game rules: move player, check boundaries, return tile. `distToPoint(10)` is pure math: convert linear distance to (x,y). Separating them means I can test `distToPoint` with simple inputs (10 → {x:0, y:1}) without instantiating a full game. High-level methods compose low-level ones. | **Real-Life**: `advance()` is "drive to the store" (high-level). `distToPoint()` is "turn steering wheel 45°" (low-level). You test steering independently of shopping. **Code**: `advance(player, 5) { const newPos = this.distToPoint(this.pointToDist(player.pos) + 5); player.pos = newPos; }` - composable, testable. |
| 30 | You have a `CyclicQueue` class for turn order. Why not just an array with a counter? | CyclicQueue encapsulates turn logic and handles edge cases (player removal, shuffling) without external bookkeeping. | Raw array: `players[index % players.length]` works until someone wins mid-game. Now you must: (1) remove player, (2) adjust index if it's past the removed player, (3) handle empty array. CyclicQueue does this internally with `remove(playerId)` and `next()`. It's a specialized data structure—reinventing it causes bugs. | **Real-Life**: CyclicQueue is a rotating sushi conveyor belt. Removing a plate doesn't break the rotation. Raw array: you manually spin plates and count—error-prone. **Code**: `activeQueue.remove(playerId); activeQueue.next();` - 2 lines. Raw: `const idx = arr.indexOf(id); arr.splice(idx,1); if (currentIdx >= idx) currentIdx--;` - 5 lines, 3 edge cases. |
| 31 | How do you test your game without a test framework? | Manual testing via console methods and debugging breakpoints. For production, I'd add Jest for unit tests. | I test interactively: `window.game.players` in DevTools, `console.log(game.winQueue)` after turns. I use `debugger;` statements to pause execution and inspect state. This works for 500 lines but doesn't scale. For real projects, I'd write Jest tests: `expect(game.advance(player, 5)).toBe(expectedPos)`. Manual testing is fast during dev but risks regression bugs. | **Real-Life**: Manual testing is taste-testing each dish. Unit tests are recipes with exact measurements—repeatable. **Code**: Manual: `console.log(game.checkWinCondition(player));`. Automated: `test('player wins at 99', () => { player.pos = new Point(9,9); expect(game.checkWinCondition(player)).toBe(true); });`. |
| 32 | Your Point class is immutable. How does this affect performance? | Immutability costs 1-2ms per game (creating new objects) but prevents 99% of state bugs. | Every position update creates a new Point: `player.pos = new Point(x, y)`. This triggers garbage collection more often than mutating `player.pos.x = x`. For 4 players, 100 turns, that's ~400 Point objects (negligible). Benefit: no accidental `player.pos.x++` bugs. If performance mattered (1000 players), I'd use mutable Points with careful validation. | **Real-Life**: Immutability is buying new shoes when dirty (safe, costs money). Mutability is cleaning shoes (fast, risk of damage). **Code**: Immutable: `player.pos = new Point(x, y); // ~0.01ms`. Mutable: `player.pos.x = x; // ~0.001ms`. For 4 players: 0.04ms vs 0.004ms difference—unnoticeable. |
| 33 | You use template literals for HTML. Why not a templating engine like Handlebars? | Template literals are native JS with zero dependencies. For 10 templates, Handlebars is overkill. | Template literals: `` `<div>${name}</div>` `` are built-in, readable, and allow arbitrary JS (loops, conditionals). Handlebars requires: (1) library import (20KB), (2) learning custom syntax (`{{#each}}`), (3) separate `.hbs` files. For a leaderboard with 5 rows, template literals are simpler. Handlebars shines with 100+ templates or when non-devs edit content. | **Real-Life**: Template literals are a notepad (always available). Handlebars is Microsoft Word (powerful, but launching it takes time). **Code**: Literal: `` players.map(p => `<li>${p.name}</li>`).join('') ``. Handlebars: `{{#each players}}<li>{{name}}</li>{{/each}}` - requires compilation step. |
| 34 | How do you handle z-index for overlapping player markers? | Dynamic z-index based on position: higher squares render on top. | Multiple players on adjacent squares can visually overlap. I set `marker.style.zIndex = position` so a player at square 50 renders above square 49. This simulates depth (players farther along appear "in front"). Without it, markers stack in DOM order (player 1 always on top), breaking immersion. | **Real-Life**: A deck of cards. Higher cards (later in the deck) appear on top. Z-index is card order. **Code**: `marker.style.zIndex = game.players.get(id).position.y * 10 + position.x;` - ensures correct layering. Player at (9,9) has z-index 99, higher than (0,0) with z-index 0. |
| 35 | Your CSS uses `rem` units. Why not `px`? | `rem` scales with user's font size preference (accessibility). `px` is fixed regardless of user settings. | `1rem` = root font size (usually 16px). If a user sets their browser to 20px (accessibility feature for vision impairment), `1rem` becomes 20px, and my entire UI scales. `px` ignores this, breaking layouts for users who need larger text. I use `rem` for fonts and spacing, `px` only for fixed elements (borders). | **Real-Life**: `rem` is a rubber band (stretches with user needs). `px` is a metal rod (fixed, inaccessible). **Code**: `font-size: 1rem; /* 16px default, 20px for low-vision users */` vs `font-size: 16px; /* always 16px, ignores user settings */`. |
| 36 | You have a `home.js` and `game-board.js`. Why not one `app.js`? | Each HTML page has its own JS controller. Splitting them prevents loading unused code. | `home.html` loads `home.js` (200 lines: form validation, player setup). `game-board.html` loads `game-board.js` (400 lines: game loop, animations). If I combined them into `app.js` (600 lines), the home page would load game code it never uses (wasted bandwidth). Separate files = code splitting = faster page loads. | **Real-Life**: One `app.js` is a Swiss Army knife (all tools, heavy). Separate files are individual tools (only carry what you need). **Code**: Home page: `<script src="home.js">` (200 lines). Game page: `<script src="game-board.js">` (400 lines). Combined: `<script src="app.js">` (600 lines on every page—wasted). |
| 37 | How do you handle the "back button" problem? (Game state lost on navigation) | I save state to LocalStorage on every turn. Returning to the game page rehydrates state. | Browsers don't preserve JS state across navigation. If a user clicks "Home" mid-game, then clicks "Back", the game resets unless I persist state. I save to LocalStorage after every turn: `localStorage.setItem('gameState', JSON.stringify(game))`. On page load, I check: `if (localStorage.gameState) { game.fromJson(localStorage.gameState); }`. | **Real-Life**: LocalStorage is a checkpoint in a video game. You can quit and resume later. **Code**: Save: `window.addEventListener('beforeunload', () => saveGameState(game));`. Load: `document.addEventListener('DOMContentLoaded', () => { if (data) game.fromJson(data); });`. |
| 38 | Your game has no authentication. How would you add user accounts? | I'd use a backend (Node.js + JWT) or Firebase Authentication for user login and cloud state sync. | LocalStorage only works on one device. For accounts, I'd: (1) Add a login page (email/password), (2) Send credentials to a server, (3) Return a JWT token, (4) Include token in headers for state sync: `fetch('/save', { headers: { 'Authorization': token }, body: gameState })`. Firebase simplifies this (no backend needed). | **Real-Life**: LocalStorage is a diary (device-specific). Accounts are a cloud diary (access anywhere). **Code**: `firebase.auth().signInWithEmailAndPassword(email, pass).then(user => { firebase.database().ref('games/' + user.uid).set(gameState); });` - cloud save with Firebase. |
| 39 | You use `Array.from()` sometimes and spread `...` other times. Why both? | `Array.from()` for array-likes (NodeList, Map keys). Spread for real arrays. | `Array.from(document.querySelectorAll('.player'))` converts NodeList (array-like, missing `.map`) to a real Array. Spread works too: `[...nodeList]`, but `Array.from` allows mapping inline: `Array.from(nodeList, el => el.textContent)`. For real arrays, spread is cleaner: `[...arr, newItem]` (concat). | **Real-Life**: `Array.from` is a translator (converts foreign objects to arrays). Spread is a copy machine (duplicates arrays). **Code**: `Array.from(map.keys())` - converts Map keys to array. `[...arr]` - shallow copy of array. Both work, different use cases. |
| 40 | How do you handle image loading delays? Do you preload assets? | Images are cached after first load. For critical assets (dice faces), I'd use preload links in HTML. | The board image (largest asset, ~200KB) loads before JS runs, so no delay. Dice faces (6 small images) load on-demand—worst case: 50ms delay on first roll. For production, I'd preload: `<link rel="preload" href="dice-1.png" as="image">` in `<head>`. This tells the browser to fetch assets during idle time. | **Real-Life**: Preloading is meal prep (cook in advance). On-demand loading is cooking each meal as needed (slower). **Code**: `<link rel="preload" href="dice-1.png" as="image">` - loads during HTML parse, before JS. Without it: `<img src="dice-1.png">` loads when first shown (potential flash of missing image). |

---

**Progress: 40/200 questions complete for Architecture track.**

Ready for the next batch? (Questions 41-60 will cover: Accessibility, SEO considerations, Build tools discussion, CDN strategies, Security best practices, and Browser DevTools usage)
