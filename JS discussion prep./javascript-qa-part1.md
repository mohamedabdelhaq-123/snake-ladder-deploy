# Core JavaScript Concepts - Technical Interview Defense (Part 1/10)

## Top 20 Most Critical JS Questions

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 1 | Explain the Event Loop and how your dice roll uses it. | The Event Loop processes synchronous code first, then queued async tasks (like setTimeout). My dice roll is synchronous, but animations are delegated to the browser's render queue. | JavaScript has one call stack (LIFO). When `rollDice()` runs, it executes line-by-line (push to stack, pop when done). CSS transitions (`transition: 0.3s`) don't block the stack—they're handled by the browser's compositor thread. The Event Loop checks: (1) Call stack empty? (2) Microtask queue (Promises) empty? (3) Macrotask queue (setTimeout) empty? Then: (4) Render frame. My game never uses setTimeout for logic, only CSS, so everything is synchronous. | **Real-Life**: A restaurant kitchen. The Event Loop is the head chef: (1) Cook orders in order (call stack), (2) Check if prep tasks are done (microtasks), (3) Check if deliveries arrived (macrotasks), (4) Serve food (render). **Code**: `rollDice(); updateUI(); console.log('done')` - all three run synchronously. No `await`, no `setTimeout`. The animation plays in parallel on the GPU. |
| 2 | What's the difference between `let`, `const`, and `var`? Why do you use `const` for functions? | `const` prevents reassignment, `let` allows it. `var` is function-scoped and hoisted. `const` functions signal "this function reference never changes." | `const` doesn't make objects immutable—it prevents the variable binding from changing. `const game = new Game()` means `game` always points to that Game instance, but `game.players` can still mutate. For functions, `const rollDice = () => {}` prevents accidental reassignment (`rollDice = null` would be a bug). `let` is for counters/flags. `var` has weird hoisting (accessible before declaration) and ignores block scope. | **Real-Life**: `const` is a wedding ring (commitment to one person). `let` is dating (can change). `var` is a messy ex who shows up uninvited (hoisting issues). **Code**: `const x = []; x.push(1); // OK, mutates array. x = []; // Error, reassignment blocked.` |
| 3 | How does `this` work in your event listeners? | `this` in regular functions refers to the element that triggered the event. Arrow functions inherit `this` from the surrounding scope. | When you do `button.addEventListener('click', function() { console.log(this) })`, `this` is the button (DOM element). Arrow functions don't have their own `this`—they use the `this` from where they were defined. I use arrow functions in event listeners because I need `this` to refer to the game object, not the button. | **Real-Life**: Regular function `this`: "I am whoever called me" (the button). Arrow function `this`: "I am whoever my parent is" (the game object). **Code**: `button.onclick = function() { console.log(this); // button }` vs `button.onclick = () => { console.log(this); // window or game object }`. |
| 4 | Explain closures with an example from your code. | A closure is when an inner function "remembers" variables from its outer function, even after the outer function returns. | In `createPlayerMarker(playerId)`, the returned function "closes over" `playerId`. Every time I call that function, it still has access to the original `playerId` value, even though `createPlayerMarker` finished executing. This is how JavaScript simulates private data—the variable exists in memory but isn't globally accessible. | **Real-Life**: You give your friend a key (closure) to your house (outer function's scope). Even after you leave town (function returns), your friend can still open the door (access variables). **Code**: `function makeCounter() { let count = 0; return () => ++count; } const c = makeCounter(); c(); // 1, c(); // 2. count is "trapped" in the closure.` |
| 5 | What's the difference between `==` and `===`? When do you use each? | `===` checks type and value. `==` coerces types, causing bugs. I always use `===` unless explicitly coercing. | `5 == '5'` is `true` because `==` converts the string to a number. `5 === '5'` is `false` because they're different types. Type coercion is unpredictable: `[] == false` is `true` (both coerce to 0), but `[] === false` is `false`. I use `===` everywhere to avoid these landmines. The only time `==` is useful: `x == null` (checks both `null` and `undefined`). | **Real-Life**: `==` is "do you look similar?" (twins pass). `===` is "are you the exact same person?" (only you pass). **Code**: `0 == false // true (why?!), 0 === false // false (clear!)`. Weird case: `'0' == false // true (string→number→boolean coercion), '0' === false // false`. |
| 6 | How does `JSON.stringify` and `JSON.parse` work? What are the limitations? | `stringify` converts JS objects to strings. `parse` converts strings back. Functions, undefined, and Dates are lost. | `JSON.stringify({ a: 1, b: undefined })` returns `'{"a":1}'` (undefined disappears). Functions also vanish: `{ fn: () => {} }` stringifies to `{}`. Dates become strings: `new Date()` → `"2024-01-01T00:00:00Z"` (you must manually reconstruct). I work around this by storing Date timestamps as numbers. Circular references (object A references object B, which references A) cause errors. | **Real-Life**: JSON is a photocopy machine. It copies text and numbers, but not the machine itself (functions) or 3D objects (complex types). **Code**: `const obj = { x: 1, fn: () => 2 }; JSON.parse(JSON.stringify(obj)); // { x: 1 } - fn is gone!` |
| 7 | What's the difference between `map`, `forEach`, and `for...of`? | `map` returns a new array. `forEach` returns undefined. `for...of` is a loop you can break out of. | `array.map(fn)` transforms each element and collects results: `[1,2,3].map(x => x*2)` → `[2,4,6]`. `forEach` just iterates for side effects (updating DOM, logging). You can't `return` early from `forEach`. `for...of` is similar to `forEach` but allows `break` and `continue`. I use `map` for transformations, `forEach` for updates, `for...of` when I need early exit. | **Real-Life**: `map` is a factory assembly line (input → transform → output). `forEach` is a quality inspector (just look, don't produce). `for...of` is a security guard (can stop and leave). **Code**: `[1,2,3].forEach(x => console.log(x)); // logs, returns undefined`. `[1,2,3].map(x => x*2); // returns [2,4,6]`. |
| 8 | Explain event delegation. Do you use it? | Event delegation attaches one listener to a parent instead of many to children. I use it for dynamically added player markers. | Instead of `marker1.onclick, marker2.onclick, marker3.onclick`, I do `board.onclick = (e) => { if (e.target.matches('.marker')) { ... } }`. This works because events "bubble" up the DOM tree. Even if markers are added later (dynamic content), the parent listener catches them. Saves memory (1 listener vs 100) and handles future elements automatically. | **Real-Life**: Hotel reception (parent) vs knocking on every room door (children). The reception handles all requests in one place. **Code**: `board.addEventListener('click', e => { if (e.target.classList.contains('player-marker')) { console.log('Clicked', e.target); }});`. One listener catches all markers. |
| 9 | What's the difference between `null` and `undefined`? | `undefined` means "never assigned." `null` means "intentionally empty." | Variables declared but not initialized are `undefined`: `let x; x === undefined`. Function parameters not passed are `undefined`. `null` is explicit: `let player = null` means "player exists but has no value yet." I use `null` for "reset to empty" and check `!= null` (catches both `null` and `undefined`). | **Real-Life**: `undefined` is an empty box you forgot about. `null` is an empty box you labeled "EMPTY". **Code**: `let x; x === undefined // true`. `let y = null; y === null // true`. But: `typeof null === 'object' // true (JavaScript bug from 1995!)`. |
| 10 | How do Promises work? Why don't you use them in your game? | Promises handle async operations (API calls, timers). My game is synchronous (no network, no delays), so I don't need them. | A Promise is a wrapper for "value coming later": `fetch(url).then(data => use(data))`. Async operations (loading images, animations) are handled by the browser natively—I don't use `setTimeout` or `fetch` in game logic. If I added multiplayer (send moves to server), I'd use Promises: `await fetch('/move', {method:'POST', body: move})`. | **Real-Life**: A Promise is a restaurant buzzer. You get it (create Promise), walk away (continue code), and it buzzes when ready (resolve/reject). **Code**: `new Promise((resolve) => { setTimeout(() => resolve('done'), 1000); }).then(console.log); // logs 'done' after 1s`. |
| 11 | What's the difference between `querySelector` and `getElementById`? | `querySelector` uses CSS selectors (flexible). `getElementById` is faster but only finds IDs. | `querySelector('.player')` finds the first element with class `player`. `querySelectorAll` finds all. `getElementById('player1')` is 2x faster (browsers optimize ID lookups with a hash map) but less flexible (can't search by class/attribute). For performance-critical code (game loop), I use `getElementById`. For one-time setup, `querySelector`. | **Real-Life**: `getElementById` is a phone book (fast, specific). `querySelector` is Google search (slower, more options). **Code**: `document.getElementById('btn')` vs `document.querySelector('#btn')` - both find the button, but first is faster. |
| 12 | How does `Array.prototype.slice()` differ from `splice()`? | `slice` returns a copy without mutating. `splice` mutates the original array. | `[1,2,3].slice(1)` returns `[2,3]`, original unchanged. `[1,2,3].splice(1,1)` removes index 1, returns `[2]`, original becomes `[1,3]`. I use `slice` for immutability (copying arrays) and `splice` when I need to remove elements (like playing a card from inventory). | **Real-Life**: `slice` is photocopying a page (original safe). `splice` is tearing out a page (original damaged). **Code**: `const arr = [1,2,3]; const copy = arr.slice(); // [1,2,3], arr unchanged`. `arr.splice(1,1); // arr is now [1,3], returns [2]`. |
| 13 | What's the difference between `appendChild` and `innerHTML`? | `appendChild` adds a DOM node. `innerHTML` parses strings as HTML. | `div.appendChild(element)` inserts a real DOM node (type-safe, fast). `div.innerHTML = '<span>Hi</span>'` parses the string, destroys old children, and creates new ones (slow, XSS risk if user input). `innerHTML` is convenient for static content. `appendChild` is safer for dynamic content. | **Real-Life**: `appendChild` is placing a Lego brick (precise). `innerHTML` is 3D printing new bricks every time (destroys old setup). **Code**: `div.innerHTML = '<b>text</b>'; // parses, creates <b>, inserts`. `div.appendChild(document.createElement('b')); // creates empty <b>, inserts`. |
| 14 | Explain `Array.prototype.reduce()`. Give an example. | `reduce` accumulates values into a single result using a callback. | `[1,2,3].reduce((sum, x) => sum + x, 0)` → `6`. The callback runs for each element: `sum=0+1=1`, `sum=1+2=3`, `sum=3+3=6`. The second argument (`0`) is the initial value. I use it for summing scores: `players.reduce((total, p) => total + p.score, 0)`. More powerful than `forEach` for aggregation. | **Real-Life**: A snowball rolling downhill (accumulator). It picks up snow (each element) and grows. **Code**: `['a','b','c'].reduce((str, char) => str + char, ''); // 'abc'`. Or: `[{x:1},{x:2}].reduce((sum, obj) => sum + obj.x, 0); // 3`. |
| 15 | What's scope? Explain lexical scope. | Scope determines where variables are accessible. Lexical scope means "where you write the code" determines access. | JavaScript uses lexical (static) scope: a function can access variables from its parent function, but not sibling functions. `function outer() { let x = 1; function inner() { console.log(x); } }` works because `inner` is written inside `outer`. This is decided at parse-time, not runtime (unlike dynamic scope in some languages). | **Real-Life**: Lexical scope is family inheritance. You inherit from your parents (outer function), not your cousins (sibling functions). **Code**: `function a() { let x = 1; function b() { console.log(x); } b(); } a(); // logs 1. b "sees" x because it's nested.` |
| 16 | What's the difference between `Object.keys()` and `for...in`? | `Object.keys()` returns own properties as an array. `for...in` iterates over own + inherited properties. | `Object.keys(obj)` gives `['key1', 'key2']` (only this object's keys, not prototype chain). `for (let key in obj)` loops over all enumerable properties, including inherited ones. I use `Object.keys()` to avoid prototype pollution bugs. If you must use `for...in`, check `obj.hasOwnProperty(key)`. | **Real-Life**: `Object.keys()` is your immediate family. `for...in` is your entire ancestry (grandparents, great-grandparents). **Code**: `const obj = { a: 1 }; Object.keys(obj); // ['a']`. But: `for (let k in obj) console.log(k); // logs 'a' + any prototype keys`. |
| 17 | What's the difference between synchronous and asynchronous code? | Synchronous blocks execution until done. Asynchronous lets other code run while waiting. | Synchronous: `const data = fetchData(); console.log(data);` - JS waits for `fetchData` to finish (blocks everything). Asynchronous: `fetchData().then(data => console.log(data));` - JS continues, logs later. My game is synchronous because all operations (calculate move, update DOM) happen instantly (<1ms). Animations don't block because they're CSS (GPU-accelerated). | **Real-Life**: Synchronous: waiting in line at a bank (everyone blocked). Asynchronous: take a number, sit down, get called when ready (others continue). **Code**: Sync: `alert('Hi'); console.log('After');` - logs only after closing alert. Async: `setTimeout(() => alert('Hi'), 1000); console.log('After');` - logs immediately. |
| 18 | What's hoisting? Why does this matter? | Hoisting moves `var` and function declarations to the top of their scope at parse-time. | `console.log(x); var x = 5;` doesn't error—`x` is `undefined` because the declaration (`var x`) is hoisted, but not the assignment (`= 5`). Functions declared with `function fn() {}` are fully hoisted (callable before declaration). `let/const` have a "temporal dead zone"—accessing them before declaration throws ReferenceError. I use `let/const` to avoid hoisting confusion. | **Real-Life**: Hoisting is like a teacher saying "any questions?" before explaining the lesson. Variables are announced early but explained later. **Code**: `console.log(x); var x = 5; // logs undefined`. But: `console.log(y); let y = 5; // ReferenceError`. |
| 19 | What's the difference between shallow copy and deep copy? | Shallow copy duplicates top-level properties. Deep copy recursively duplicates nested objects. | `const copy = {...original}` is shallow—if `original.obj = {a:1}`, then `copy.obj` points to the same object (changing `copy.obj.a` changes `original.obj.a`). Deep copy: `JSON.parse(JSON.stringify(original))` (loses functions) or `structuredClone(original)` (modern, preserves most types). I use shallow copy for simple data (player names) and deep copy for game state (nested arrays/objects). | **Real-Life**: Shallow copy is duplicating a folder structure (folders copied, but files inside are shortcuts to originals). Deep copy duplicates folders AND files. **Code**: `const a = {x: {y: 1}}; const b = {...a}; b.x.y = 2; a.x.y === 2; // true (shared reference!)`. Deep: `const b = JSON.parse(JSON.stringify(a)); b.x.y = 2; a.x.y === 1; // isolated`. |
| 20 | Explain `setTimeout` vs `setInterval`. Why don't you use them? | `setTimeout` runs once after a delay. `setInterval` repeats on an interval. I use CSS transitions instead for animations. | `setTimeout(() => console.log('Hi'), 1000)` logs after 1s. `setInterval(() => console.log('Hi'), 1000)` logs every 1s (must be cleared with `clearInterval`). These are async (macrotasks in Event Loop). CSS transitions (`transition: 0.3s`) are faster (GPU thread) and don't block JavaScript. If I animated with `setInterval`, the game would stutter during moves. | **Real-Life**: `setTimeout` is an alarm clock (one ring). `setInterval` is a metronome (repeating tick). **Code**: `setTimeout(() => alert('Time!'), 2000); // shows after 2s`. `let id = setInterval(() => console.log('tick'), 1000); clearInterval(id); // stops`. |

---

**Progress: 20/200 questions complete for JavaScript track.**

Ready for the next batch? (I'll continue with questions 21-40, covering: Prototypal inheritance, Spread/Rest operators, Template literals, Destructuring, Modules vs scripts, and Memory leaks)
