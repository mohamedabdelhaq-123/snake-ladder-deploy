# Architecture & Design Decisions - Interview Defense Bank (Part 1/10)

## Top 20 Most Critical Questions

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 1 | Why did you use LocalStorage instead of a database? Isn't that unprofessional? | LocalStorage is perfect for client-side, single-player-per-device games with no backend requirement. | LocalStorage provides synchronous, persistent key-value storage (5-10MB) directly in the browser. For a game where state needs to survive page refreshes but doesn't need to sync across devices or users, it's the optimal choice. No server = no hosting costs, no API calls, instant reads/writes. A database would require a backend server (Node.js + Express), authentication, and network latency for every game action. | **Real-Life**: It's like saving your game progress on a Nintendo cartridge vs uploading to a cloud server. For a local, single-player experience, the cartridge (LocalStorage) is faster and simpler. **Code**: `localStorage.setItem('gameState', JSON.stringify(game))` - instant save, no network roundtrip. |
| 2 | Your game state uses JSON.stringify/parse extensively. Why not use a proper state management library like Redux? | For a game with 4-5 state properties, Redux adds 10x complexity for zero benefit. | Redux is designed for apps with dozens of interconnected components sharing state (like a social media feed with comments, likes, notifications). My game has a linear state: `{players, activeQueue, winQueue, grid}`. The overhead of actions, reducers, and middleware would make the codebase harder to read for a problem that `JSON.stringify` solves in 1 line. | **Real-Life**: Using Redux here is like hiring a professional moving company to move a single chair across the room. **Code**: My entire save logic: `localStorage.setItem('gameState', game.toJson())`. Redux equivalent: 50+ lines of boilerplate (actions, reducers, store setup). |
| 3 | You built this with Vanilla JS. Why not React/Vue? Are you avoiding modern frameworks? | I chose Vanilla JS to demonstrate deep understanding of DOM APIs and browser fundamentals, not framework magic. | Frameworks abstract away DOM manipulation, but they add build tools (Webpack, Babel), dependencies (node_modules), and learning curves. For a 10-component game with deterministic state updates (dice roll → move player → check tile), direct DOM manipulation is faster to develop and debug. React shines when you have 100+ components with complex re-render logic. | **Real-Life**: React is a calculator app on your phone. Vanilla JS is doing math by hand. For simple problems, doing it by hand proves you understand the fundamentals. **Code**: `playerMarker.style.transform = 'translate(x, y)'` is clearer than `useState` + `useEffect` + virtual DOM diffing. |
| 4 | How do you handle race conditions when multiple dice rolls happen quickly? | I disable the "Roll Dice" button immediately after click and re-enable only after the turn completes. | Race conditions occur when async operations (animations, state updates) overlap. If a user clicks "Roll Dice" twice in 200ms, the second click could corrupt the game state (Player A moves, then Player B's animation starts, but Player A's turn isn't marked complete). Disabling the button during the critical section (roll → animate → update queue → save) ensures atomic turn execution. | **Real-Life**: It's like a bathroom door lock. Once someone enters (starts a turn), the door locks (button disabled) until they exit (turn ends). **Code**: `rollButton.disabled = true; await animateMovement(); game.updateQueues(); rollButton.disabled = false;` |
| 5 | Your grid uses a 1D array but displays as a 2D board. Why this mismatch? | The board is conceptually 1D (squares 0-99 in sequence), but displayed as 10x10 for visual clarity. | Internally, the game logic treats movement as linear distance (`position += diceRoll`). Converting to 2D coordinates is purely for rendering: `x = position % 10, y = Math.floor(position / 10)`. This separation of concerns keeps game logic simple (no diagonal movement bugs) while the UI layer handles visual layout. | **Real-Life**: A racetrack is 1D (lap distance), but displayed on a 2D map. Drivers think in "miles remaining", not "turn left at coordinate (5,3)". **Code**: `pointToDist(point) { return point.x + point.y * width; }` - converts rendering position back to game logic distance. |
| 6 | You have a CyclicQueue class. Why not just use a regular array with modulo arithmetic? | CyclicQueue encapsulates turn-order logic and prevents off-by-one errors in player removal. | A raw array with `currentIndex % length` seems simple until you remove a player mid-game (someone wins). Suddenly, indices shift, and `currentIndex` points to the wrong player. CyclicQueue handles this by tracking removed players and adjusting the internal pointer automatically. It's a reusable abstraction. | **Real-Life**: Musical chairs. The CyclicQueue is the person managing the music and removing chairs. A raw array is just a list of chair numbers—you'd have to manually recount every time someone sits. **Code**: `activeQueue.remove(playerId)` - internally shifts indices without breaking the loop. Doing this manually: 15 lines of buggy index math. |
| 7 | Why are Tiles and Cards separate classes? They both trigger effects. | Tiles are board-permanent (snakes/ladders), Cards are player-inventory (consumables). Separating them enforces different lifecycles. | Tiles exist on the grid and trigger automatically when stepped on. Cards are collected, stored in player inventory (max 3), and triggered manually. Merging them would mix concerns: "Is this effect positional or intentional?" Separate classes mean separate validation (Tiles need position, Cards need target player). | **Real-Life**: Tiles are landmines (you step on them). Cards are grenades (you throw them). Both explode, but their triggers are fundamentally different. **Code**: `class Tile { effect(game, player) }` vs `class Card { effect(game, player, params) }` - Cards need `params` for targeting. |
| 8 | Your Point class is immutable. Why not just use `{x, y}` objects? | Immutability prevents accidental state mutations and makes debugging 10x easier. | Mutable objects allow `player.position.x++`, which bypasses validation and creates bugs (player moves off-grid). Immutable Points force you to write `player.position = new Point(x, y)`, triggering the setter validation. This is defensive programming—if state is corrupted, you know exactly where (the setter). | **Real-Life**: A locked safe vs a cardboard box. With the box (mutable object), anyone can change contents without your knowledge. The safe (immutable) forces them to go through the combination (setter). **Code**: Without immutability, a bug could do `player.position.x = -5` silently. With immutability, `player.position = invalidPoint` throws an error immediately. |
| 9 | You check `position.key() === goal.key()` for win conditions. Why not `position === goal`? | JavaScript compares objects by reference, not value. Two Points with the same coordinates are different objects. | `{x:5, y:5} === {x:5, y:5}` is `false` because they're different memory addresses. The `key()` method serializes the Point to a string (`"5,5"`), enabling value-based comparison. This is a workaround for JS not having structural equality like Python tuples. | **Real-Life**: Two people wearing identical shirts aren't the same person (reference equality). Comparing their shirt labels (value equality) tells you they match. **Code**: `key() { return `${this.x},${this.y}`; }` - converts `Point(5,5)` to `"5,5"` for Map keys and comparisons. |
| 10 | How do you prevent cheating via LocalStorage manipulation? | I don't—this is a local, trusted-user game. For competitive play, I'd hash the state or use server-side validation. | LocalStorage is client-side and fully editable via DevTools. A malicious user could `localStorage.setItem('gameState', '...')` to teleport to square 99. Mitigation options: (1) Hash the state with a secret key (still bypassable with debugger), (2) Move state to a backend (requires server), (3) Accept it as a limitation of client-side games. For a casual game, option 3 is pragmatic. | **Real-Life**: A board game at home. You could flip the board and cheat, but why? There's no prize. For a tournament (competitive), you'd need a referee (server). **Code**: Defense would look like: `const hash = SHA256(gameState + SECRET); if (storedHash !== hash) { alert('Tampering detected'); }` - but this is overkill for this use case. |
| 11 | Your CSS uses Flexbox/Grid. Why not a UI library like Material-UI or Tailwind? | Raw CSS Flexbox/Grid demonstrates layout mastery without abstraction dependencies. | Material-UI bundles 1MB+ of JavaScript for components I don't need (autocompletes, modals, themes). Tailwind requires a build step (PostCSS) and learning its utility-class system. For a 5-page game with fixed layouts, writing 200 lines of custom CSS is faster and lighter than configuring a framework. | **Real-Life**: Material-UI is a fully-furnished apartment. Raw CSS is building your own furniture. For 3 pieces of furniture, DIY is faster. **Code**: `display: flex; justify-content: space-between;` is 2 lines. Material-UI equivalent: `import { Box } from '@mui/material'; <Box display="flex" justifyContent="space-between">` - more typing, same result. |
| 12 | You use ES6 modules (`import/export`). Why not a bundler like Webpack? | ES6 modules work natively in modern browsers without build tools, keeping the dev workflow instant. | Webpack bundles all JS into one file, which helps with HTTP/1.1 (reduce requests) but adds complexity: `webpack.config.js`, dev server, minification, source maps. For a 15-file project, native modules load fast enough (HTTP/2 multiplexes them), and I avoid the "it compiles" step. Changes are instant—refresh and see results. | **Real-Life**: Webpack is a factory assembly line (efficient for 1000 products). Native modules are a craftsman's workshop (perfect for 15 handmade items). **Code**: `<script type="module" src="game.js"></script>` - works immediately. Webpack: `npm install webpack webpack-cli`, config file, build script. |
| 13 | Your game loop is synchronous. What if animations take too long? | Animations are CSS transitions, which are non-blocking. JavaScript just triggers them and continues. | I don't use `while` loops or blocking delays. Movement animation is `playerMarker.style.transform = ...` with `transition: 0.3s ease`, which the browser handles on the GPU thread. JavaScript execution doesn't pause. The button disable prevents new turns, but the current turn logic finishes instantly. | **Real-Life**: You press a button to start a washing machine (trigger animation), then walk away (continue code). You don't stand there waiting for it to finish. **Code**: `playerMarker.style.transform = 'translate(100px, 200px)'; console.log('I run immediately after!');` - both happen in the same frame. |
| 14 | How do you handle browser compatibility? Did you test on Safari/Firefox? | I use standard APIs (LocalStorage, Flexbox, ES6) with 95%+ support. Graceful degradation for older browsers. | I avoided bleeding-edge features (CSS Grid subgrid, ES2023 syntax). The fallback strategy: (1) Check `localStorage` support with `if (typeof Storage !== 'undefined')`, (2) Use `-webkit-` prefixes where needed, (3) Test on Chrome, Firefox, Safari. Polyfills (like Babel) would add build complexity for <5% user benefit. | **Real-Life**: Building a house with standard lumber (widely available) vs exotic wood (rare, needs special suppliers). **Code**: `if (!localStorage) { alert('Upgrade your browser'); return; }` - block execution on IE9 rather than debugging obscure bugs. |
| 15 | Your code has lots of `// TODO` comments. Is this production-ready? | TODOs mark known limitations and future optimizations. In an interview, they show I think critically about my code. | Every TODO is intentional: `// TODO: validate position range` means "I know this edge case exists, I prioritized shipping over perfect validation." In production, I'd remove them after addressing each. Leaving them in a portfolio shows honesty—I'm aware of imperfections and can articulate trade-offs. | **Real-Life**: A chef saying "This dish could use less salt next time" shows mastery. Pretending it's perfect shows ignorance. **Code**: `// TODO: replace hard-coded 3 with MAX_CARDS constant` - shows I know magic numbers are technical debt. |
| 16 | You have a separate `PlayerAccountData` and `PlayerGameData`. Why the duplication? | AccountData is persistent (name, avatar). GameData is ephemeral (position, cards). Separating them allows independent lifecycles. | AccountData survives across games (stored in LocalStorage, reused in leaderboard). GameData resets every match. If they were merged, resetting the game would wipe player names, breaking the leaderboard. This is the Single Responsibility Principle—one class for identity, one for state. | **Real-Life**: Your driver's license (account) vs your current location (game state). You keep your license, but your location changes daily. **Code**: `PlayerAccountData { name, imgNumber }` persists. `PlayerGameData { position, cards }` is recreated each game. |
| 17 | Your Card.effect() method takes a `params` argument. Why not strongly type it? | JavaScript is dynamically typed. I use JSDoc comments to document expected params without TypeScript's build overhead. | TypeScript would catch `effect(game, player, 'wrong type')` at compile time, but requires `tsconfig.json`, type definitions, and `tsc` compilation. For a 500-line project, JSDoc comments (`@param {number} playerId`) give 80% of the benefit (IDE autocomplete, documentation) with zero build step. | **Real-Life**: TypeScript is a spell-checker that blocks you from sending emails with typos. JSDoc is a grammar guide you consult yourself. **Code**: `/** @param {Game} game */ effect(game, player, params) { }` - VS Code shows `game` is type `Game` without compilation. |
| 18 | Your grid validation throws errors. Shouldn't you handle them gracefully with try-catch? | Errors should crash during development. In production, I'd wrap public APIs in try-catch, but internal validation should fail fast. | `throw new Error("Invalid position")` during `addTile()` means a programmer error (I passed bad data). Catching it would hide the bug—the game would continue with corrupted state. In production, public-facing code (like user input) gets try-catch, but private logic (game engine) should scream loudly when assumptions break. | **Real-Life**: If your car's engine has a fatal issue, you want it to stop (throw error) rather than limp along and explode later (catch and continue). **Code**: Dev: `if (!valid) throw new Error()`. Production: `try { game.playTurn() } catch(e) { showErrorUI(e); }` - catch at the boundary, not internally. |
| 19 | You use `Array.forEach()` instead of `for` loops. Isn't that slower? | `forEach` is 5-10% slower but infinitely more readable. For a 4-player game, the difference is 0.0001ms. | Premature optimization is the root of all evil. `forEach` prevents off-by-one errors (`for (i=0; i<length; i++)` is error-prone). Unless profiling shows a bottleneck (it won't for 4 players), readability beats micro-optimizations. A `for` loop would save 0.01ms per frame in exchange for buggier code. | **Real-Life**: Flying economy vs first-class for a 10-minute flight. The time saved (30 seconds) doesn't justify the cost (complexity). **Code**: `players.forEach(p => update(p))` vs `for (let i=0; i<players.length; i++) update(players[i])` - 1 line vs 3, same runtime for small arrays. |
| 20 | If you had 6 more months, what would you refactor? | I'd extract a GameEngine class, add unit tests, and implement undo/redo with the Command pattern. | Right now, `game.js` is 300 lines doing too much (turn logic, queue management, win conditions). I'd split it into `TurnEngine`, `WinConditionChecker`, `StateSerializer`. Testing is manual (click around)—I'd add Jest tests for edge cases (player removal mid-turn). Undo/redo would require the Command pattern (store each action as an object: `{type: 'move', player, from, to}`). | **Real-Life**: My code is a Swiss Army knife (one tool, many functions). Refactored: a toolbox (many tools, one function each). **Code**: Current: `game.playTurn()` does 10 things. Refactored: `engine.rollDice(); engine.movePlayer(); engine.checkTiles(); winChecker.check();` - each class has 1 job. |

---

**Progress: 20/200 questions complete for Architecture track.**

Ready for the next batch? (I'll continue with questions 21-40, covering: Mobile responsiveness, Event Delegation, Animation strategy, File structure organization, and Performance optimizations)
