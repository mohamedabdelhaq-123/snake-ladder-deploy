# Architecture & Design Decisions - Interview Defense Bank (Part 3/10)

## Questions 41-60: Accessibility, Security & Advanced Architecture

| # | The Tough Question | Perfect Simple Answer | Under the Hood Explanation | Code/Real-Life Example |
|---|-------------------|----------------------|---------------------------|----------------------|
| 41 | How do you ensure keyboard accessibility? Can users play without a mouse? | I use semantic HTML (buttons, not divs) and test tab navigation. Mouse-only interactions would fail WCAG. | Semantic elements (`<button>` vs `<div onclick>`) are keyboard-accessible by default (Space/Enter trigger clicks). I ensure: (1) All interactive elements are focusable (`tabindex` if needed), (2) Focus order is logical (top→bottom, left→right), (3) Focus indicators are visible (`:focus` CSS). Testing: tab through the page—can you roll dice, play cards, navigate? | **Real-Life**: Keyboard navigation is wheelchair ramps (legal requirement, not optional). Mouse-only is stairs (excludes users). **Code**: Good: `<button onclick="roll()">Roll</button>` - keyboard works. Bad: `<div onclick="roll()">Roll</div>` - not focusable. Fix: add `tabindex="0"` and `onkeydown="if(e.key==='Enter') roll()"`. |
| 42 | Do you use ARIA labels? How do screen readers understand your game? | I use ARIA labels for dynamic content (dice results, turn announcements). Static content uses semantic HTML. | Screen readers rely on: (1) Semantic HTML (`<button>`, `<nav>`), (2) Alt text for images (`<img alt="Player 1 marker">`), (3) ARIA for dynamic updates: `<div role="status" aria-live="polite">Player 2's turn</div>` announces changes. I avoid ARIA when HTML suffices (don't add `role="button"` to `<button>`—redundant). | **Real-Life**: ARIA is closed captions for the deaf. Without it, screen reader users "watch" a silent movie. **Code**: `<button>Roll Dice</button>` - screen reader says "Roll Dice, button". `<div id="result" aria-live="assertive">Rolled a 6!</div>` - announces immediately. `aria-live="polite"` waits for user to pause. |
| 43 | How do you handle color contrast for visually impaired users? | I test with WCAG contrast checkers (4.5:1 ratio minimum). Avoid color-only information. | WCAG AA requires 4.5:1 contrast (text/background). I use tools (WebAIM Contrast Checker) to verify. Mistakes: red/green for win/loss (colorblind users can't distinguish). Fix: add icons (✓/✗) or text labels. I never rely on color alone to convey state (buttons say "Your Turn", not just turn green). | **Real-Life**: Low contrast is whispering in a loud room (some hear, many don't). High contrast is shouting clearly. **Code**: Bad: `color: #ccc; background: #fff;` (1.2:1 ratio, fails). Good: `color: #333; background: #fff;` (12.6:1, passes). Colorblind-safe: `<span class="win">✓ You Won!</span>` (icon + text, not just green). |
| 44 | Your game has no search engine optimization. Would you add meta tags? | For a web app (not content site), SEO is low priority. But I'd add Open Graph tags for social sharing. | Search engines rank content pages (blogs, products), not web apps. My game has no indexable content (it's dynamic, state-driven). If I wanted SEO: (1) Add `<meta name="description">`, (2) Use semantic headings (`<h1>Snake & Ladders</h1>`), (3) Add structured data (JSON-LD for "Game"). For social: Open Graph tags let previews show on Twitter/Facebook. | **Real-Life**: SEO is advertising a storefront (content sites). My app is a private game room (not meant to be found via Google). **Code**: `<meta name="description" content="Play Snake & Ladders with friends">` (SEO). `<meta property="og:image" content="preview.jpg">` (social sharing thumbnail). |
| 45 | How do you prevent XSS (Cross-Site Scripting) attacks? | I never use `innerHTML` with user input. All user data goes through `textContent` or parameterized templates. | XSS happens when malicious scripts execute via user input. If I do `div.innerHTML = userInput` and `userInput = '<script>alert("hacked")</script>'`, the script runs. Defense: (1) Use `textContent` (treats everything as text, not HTML), (2) Sanitize with DOMPurify if HTML needed, (3) Use template literals with variables (auto-escaped in most contexts). | **Real-Life**: XSS is someone writing "free food" on a restaurant door (tricks people into entering a trap). Sanitization is checking IDs at the door. **Code**: Bad: `div.innerHTML = userName; // userName = '<img src=x onerror=alert(1)>'`. Good: `div.textContent = userName; // renders as literal text, no execution`. Sanitize: `div.innerHTML = DOMPurify.sanitize(richText);`. |
| 46 | What's CSRF? Does your game have this vulnerability? | CSRF tricks users into making unintended requests. My game has no backend, so no CSRF risk. | CSRF exploits authenticated sessions. Example: evil site makes your browser send `POST /transfer?to=attacker` to your bank (cookies auto-sent). Defense: (1) CSRF tokens (server generates secret, form includes it), (2) SameSite cookies. My game uses LocalStorage (no cookies, no server)—CSRF doesn't apply. | **Real-Life**: CSRF is someone forging your signature on a check (because the bank trusts "anyone with your ID"). No bank account (backend) = no fraud risk. **Code**: Vulnerable: `<form action="https://bank.com/transfer" method="POST">` on evil site submits using victim's cookies. Defense: `<input type="hidden" name="csrf_token" value="random_secret">` - server validates token. |
| 47 | How do you sanitize user input (player names)? | I validate with regex (letters only) and limit length. For display, I use `textContent` to prevent HTML injection. | Player names pass through: (1) Client validation: `if (!/^[a-zA-Z]+$/.test(name)) { reject }` (only letters), (2) Length check: `if (name.length > 20) { reject }`, (3) Display: `element.textContent = name` (treats as text, not HTML). Even if someone bypasses client validation (DevTools), `textContent` prevents script execution. | **Real-Life**: Input validation is a bouncer checking IDs (rejects fakes). `textContent` is a safety net (even if a fake gets in, no weapons allowed). **Code**: `const name = input.value; if (!/^[a-z]+$/i.test(name)) { alert('Letters only'); return; } playerDiv.textContent = name; // safe even if name = '<script>alert(1)</script>' (renders as text)`. |
| 48 | Your LocalStorage data is unencrypted. Is this a security issue? | For a local game with no sensitive data, it's acceptable. For payment info, I'd use encryption or server storage. | LocalStorage is plain text (anyone with DevTools can read it). My game stores: player names, positions, scores—not sensitive. If storing credit cards: (1) Never use LocalStorage (use server), (2) If client-side needed, encrypt with Web Crypto API. But encryption in JS is bypassable (attacker can read code). True security requires server-side storage. | **Real-Life**: LocalStorage is a diary under your pillow (local attacker can read). Server is a bank vault (protected even if your house is robbed). **Code**: Insecure: `localStorage.setItem('card', '1234-5678')`. Better: `const encrypted = await crypto.subtle.encrypt(key, data); localStorage.setItem('card', encrypted);`. Best: `fetch('/api/store-card', {method:'POST', body: card});` - server handles it. |
| 49 | How do you handle Content Security Policy (CSP)? | I don't use inline scripts/styles. A strict CSP would block `<script>` tags, requiring external `.js` files. | CSP is an HTTP header that blocks inline code: `Content-Security-Policy: script-src 'self'` allows only scripts from my domain. Inline `<script>alert(1)</script>` would be blocked. My code already uses external files (`<script src="game.js">`), so it's CSP-compatible. Inline styles (`<div style="color:red">`) would need refactoring to classes. | **Real-Life**: CSP is a whitelist for parties (only invited guests enter). Inline code is party crashers (blocked). **Code**: Blocked by CSP: `<script>doThing()</script>`, `<div style="...">`. Allowed: `<script src="app.js"></script>`, `<link rel="stylesheet" href="style.css">`. CSP header: `script-src 'self'; style-src 'self'`. |
| 50 | How do you debug production issues? Do you use error monitoring (Sentry, Rollbar)? | I use browser DevTools (console, network tab). For production, I'd add Sentry to capture client-side errors automatically. | DevTools shows: (1) Console errors (uncaught exceptions), (2) Network failures (404s, CORS), (3) Performance (Timeline). Sentry adds: (1) Error aggregation (groups similar errors), (2) Stack traces from users' browsers, (3) Breadcrumbs (what user did before crash). I'd wrap the game loop: `window.onerror = (msg, url, line) => { Sentry.captureException({msg, url, line}); }`. | **Real-Life**: DevTools is fixing your own car (manual inspection). Sentry is a mechanic who receives error reports from all customers automatically. **Code**: `window.onerror = (msg, src, line, col, error) => { fetch('/log', {method:'POST', body: JSON.stringify({msg, src, line, error})}); };` - logs errors to server. Sentry does this automatically. |
| 51 | How do you profile performance? What tools do you use? | Chrome DevTools Performance tab. I record a game session and identify slow functions (yellow bars = scripting, purple = rendering). | Performance tab shows: (1) Flame graph (which functions took longest), (2) Frame rate (should be 60fps), (3) Memory usage (spikes = leaks). I look for: (1) Long tasks (>50ms blocks UI), (2) Forced reflows (reading `offsetHeight` after changing styles), (3) Memory leaks (heap grows indefinitely). I optimize hot paths (functions called 100+ times). | **Real-Life**: Profiling is a time-lapse video of your workflow (shows where you waste time). Without it: guessing blindly. **Code**: Record → play game → stop. Look for: `advancePlayer() - 200ms` (too slow). Optimize: avoid DOM reads in loops. `players.forEach(p => { div.style.left = p.x + 'px'; getComputedStyle(div); })` - reflow each iteration (slow). Fix: batch reads/writes. |
| 52 | Do you use service workers for offline support? | No—my game requires no network, so offline support is automatic. Service workers would help cache assets for faster reloads. | Service workers cache files (HTML, JS, CSS, images) so the app loads without network. My game already works offline (no API calls), but first load needs network. Adding a service worker would cache the shell: `cache.addAll(['index.html', 'game.js', 'board.jpg'])`. Next visit: instant load from cache. | **Real-Life**: Service worker is downloading Netflix movies (watch offline later). Without it: stream every time (requires network). **Code**: `navigator.serviceWorker.register('/sw.js'); // sw.js: self.addEventListener('install', e => { e.waitUntil(caches.open('v1').then(cache => cache.addAll(['/index.html', '/app.js']))); });` - caches assets on install. |
| 53 | Your code has magic numbers (3 max cards, 6 dice sides). Why not constants? | I agree—magic numbers are technical debt. I'd refactor to `const MAX_CARDS = 3` for readability and maintainability. | Magic numbers (`if (cards.length < 3)`) are cryptic. Constants (`if (cards.length < MAX_CARDS)`) are self-documenting. If I change the rule (4 max cards), I update one constant vs searching for all `3`s in the codebase. I left TODOs for this—prioritized shipping over perfect refactoring. | **Real-Life**: Magic numbers are insider jargon ("bring me a 9/16"). Constants are plain English ("bring the wrench"). **Code**: Bad: `if (cards.length < 3) pushCard();`. Good: `const MAX_CARDS = 3; if (cards.length < MAX_CARDS) pushCard();`. Later: change `MAX_CARDS = 4` in one place vs hunting for every `3`. |
| 54 | How would you implement undo/redo functionality? | I'd use the Command pattern: store each action as an object `{type, data}`, push to history, and replay/reverse on undo/redo. | Each turn becomes a command: `{type: 'move', playerId: 1, from: 10, to: 15}`. Undo stack stores commands. Undo: pop command, reverse it (`player.pos = command.from`). Redo: replay command. Memento pattern alternative: snapshot entire game state after each turn (simpler but memory-heavy). | **Real-Life**: Command pattern is a video recording (replay/reverse actions). Memento is taking photos (restore full snapshots). **Code**: `class MoveCommand { execute(game) { this.from = player.pos; player.pos = newPos; } undo(game) { player.pos = this.from; } } undoStack.push(new MoveCommand()); undo() { undoStack.pop().undo(game); }`. |
| 55 | How do you handle deep linking (sharing a game URL with state)? | I'd encode game state in the URL query string: `game.html?state=base64encodedJSON`. On load, parse and restore state. | URL: `game.html?state=eyJwbGF5ZXJzIjp7...}}` (Base64-encoded game state). On load: `const params = new URLSearchParams(location.search); const state = atob(params.get('state')); game.fromJson(state);`. Users can bookmark or share the link. Alternative: generate short IDs (store state server-side, link to ID). | **Real-Life**: Deep linking is mailing a board game setup (recipient resumes from exact state). Without it: "set up the board yourself, guess where we were". **Code**: Save: `const encoded = btoa(game.toJson()); window.history.pushState({}, '', `?state=${encoded}`);`. Load: `const state = atob(new URLSearchParams(location.search).get('state')); game.fromJson(state);`. |
| 56 | Your CSS is global. Why not CSS Modules or scoped styles? | For a 3-page app, global CSS with BEM naming is sufficient. Modules add build complexity for minimal benefit. | CSS Modules (`import styles from './Button.module.css'`) auto-scope classes (`.button` becomes `.Button_button_a3x2`). Prevents naming collisions in large apps (1000+ components). My game has 10 components—I use BEM (`.player-info__name`, `.player-info__score`) to avoid conflicts manually. Modules require Webpack/Vite (build step). | **Real-Life**: Global CSS is a small town (everyone knows each other, no name conflicts). CSS Modules are a city (need unique IDs to avoid confusion). **Code**: Global: `.card { ... } .player-card { ... }` - manual namespacing. Modules: `import s from './Card.module.css'; <div className={s.card}>` - auto-scoped to `.Card_card_x7j3`. |
| 57 | How do you handle timezone issues with Date objects? | I store timestamps as UTC (milliseconds since epoch) and convert to local time for display only. | `new Date()` uses local timezone. If I save `date.toString()` and a user in a different timezone loads it, the time shifts. Solution: store `date.getTime()` (UTC milliseconds) or ISO string (`date.toISOString()`). Display: `new Date(timestamp).toLocaleString()` (auto-converts to user's timezone). | **Real-Life**: Storing local time is saying "meet at 3pm" without timezone (confusing for remote teams). Storing UTC is "meet at 2024-01-01T15:00:00Z" (unambiguous). **Code**: Bad: `localStorage.setItem('time', new Date().toString());` (timezone-dependent). Good: `localStorage.setItem('time', Date.now());` (UTC ms). Display: `new Date(parseInt(stored)).toLocaleString();` (converts to user's timezone). |
| 58 | How would you implement multiplayer (real-time syncing)? | I'd use WebSockets or Firebase Realtime Database. Each player's move broadcasts to all clients, updating their local state. | WebSocket: client connects to server, sends moves: `ws.send(JSON.stringify({type:'move', player:1, pos:15}))`. Server broadcasts to all clients. Clients update local game state. Firebase: `firebase.database().ref('games/123/moves').on('child_added', (move) => { applyMove(move); })`. Challenges: conflict resolution (two players roll simultaneously), latency compensation (optimistic updates). | **Real-Life**: Multiplayer is walkie-talkies (instant broadcast). Turn-based is mailing letters (delayed). **Code**: WebSocket: `ws.onmessage = (e) => { const move = JSON.parse(e.data); game.advancePlayer(move.player, move.roll); updateDOM(); };`. Firebase: `db.ref('game').on('value', snap => { game.fromJson(snap.val()); });`. |
| 59 | How do you handle browser differences (Safari, Firefox, Edge)? | I test on Chromium (Chrome/Edge), Firefox, and Safari. Use feature detection, not browser detection. | Browser detection (`if (isChrome)`) breaks when browsers update. Feature detection (`if ('localStorage' in window)`) is robust. I test: (1) Flexbox (Safari has old bugs), (2) ES6 modules (IE11 doesn't support), (3) LocalStorage (private mode blocks it). Polyfills (Babel, core-js) add missing features to old browsers, but increase bundle size. | **Real-Life**: Feature detection is "can you swim?" vs browser detection "are you wearing a swimsuit?" (swimsuit doesn't guarantee swimming). **Code**: Bad: `if (navigator.userAgent.includes('Chrome'))`. Good: `if ('IntersectionObserver' in window) { useIntersectionObserver(); } else { fallbackToScrollListener(); }`. |
| 60 | How do you document your code for other developers? | I use JSDoc comments for public APIs and README files for setup instructions. | JSDoc: `/** @param {Game} game @returns {boolean} */ function checkWin(game)` - IDEs show hints. README: explains project structure, how to run (`npm start`), architecture decisions. For complex logic, I add inline comments: `// Modulo arithmetic treats board as 1D array`. Over-commenting is bad (explain "why", not "what"—code shows "what"). | **Real-Life**: Documentation is a treasure map (helps others navigate). No docs: they wander blindly. **Code**: `/** * Advances player by dice roll. Handles boundary checks. * @param {number} playerId - The player to move * @param {number} steps - Number of spaces to advance * @returns {Tile|undefined} - Tile landed on, if any */ advancePlayer(playerId, steps) { ... }`. |

---

**Progress: 60/200 questions complete for Architecture track.**

Ready for the next batch? (Questions 61-80 will cover: Progressive Web Apps, Performance budgets, Code splitting strategies, Caching strategies, Animation performance, and Design patterns like Observer, Factory, and Singleton)
